<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>ORCID Matcher</title>
    <style>
      :root {
        font-family: "Segoe UI", "Roboto", system-ui, sans-serif;
        color: #0f172a;
        background-color: #e5e7ff;
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
        margin: 0;
      }
      body {
        background: linear-gradient(180deg, #edf0ff, #e2e8ff 60%);
      }
      .app {
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        gap: 1rem;
        padding: 2rem;
      }
      .hero {
        background: #ffffff;
        border-radius: 20px;
        padding: 1.75rem;
        box-shadow: 0 20px 60px rgba(15, 23, 42, 0.15);
        max-width: 1200px;
        width: min(1200px, 100%);
        margin: 0 auto;
      }
      .hero h1 {
        margin: 0;
        font-size: 2rem;
      }
      .hero p {
        margin: 0.5rem 0 0;
        color: #475569;
        line-height: 1.45;
        max-width: 820px;
      }
      .controls {
        margin-top: 1.25rem;
        display: flex;
        flex-direction: column;
        gap: 0.85rem;
      }
      .controls textarea {
        width: 100%;
        min-height: 180px;
        border-radius: 14px;
        border: 1px solid #cbd5f5;
        padding: 0.95rem;
        font-family: "JetBrains Mono", "Fira Code", monospace;
        background: #f8fafc;
        resize: vertical;
      }
      .controls-row {
        display: flex;
        flex-wrap: wrap;
        gap: 0.6rem;
        align-items: center;
      }
      .controls button {
        padding: 0.65rem 1.4rem;
        background: #2563eb;
        border: none;
        border-radius: 10px;
        color: #fff;
        font-weight: 600;
        cursor: pointer;
        box-shadow: 0 8px 16px rgba(37, 99, 235, 0.35);
      }
      .controls button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        box-shadow: none;
      }
      .status {
        margin: 0;
        font-size: 0.95rem;
        color: #475569;
      }
      .master-detail {
        flex: 1;
        display: grid;
        grid-template-columns: minmax(280px, 1fr) minmax(0, 2fr);
        gap: 1rem;
        min-height: 0;
        height: calc(100vh - 2rem);
        max-height: calc(100vh - 2rem);
        position: sticky;
        top: 0;
        overflow: hidden;
      }
      .panel {
        background: #ffffff;
        border-radius: 20px;
        padding: 1.25rem;
        display: flex;
        flex-direction: column;
        gap: 1rem;
        min-height: 0;
        height: 100%;
        box-shadow: 0 14px 40px rgba(15, 23, 42, 0.08);
      }
      .panel-header {
        display: flex;
        justify-content: space-between;
        gap: 1rem;
        align-items: flex-start;
      }
      .panel-header h2 {
        margin: 0;
        font-size: 1.3rem;
      }
      .panel-header p {
        margin: 0;
        color: #475569;
        font-size: 0.9rem;
      }
      .inline-field {
        padding: 0.6rem 0.9rem;
        border-radius: 10px;
        border: 1px solid #cbd5f5;
        font-size: 0.95rem;
        background: #fff;
      }
      .panel input {
        width: 100%;
      }
      .authors-panel {
        display: flex;
        flex-direction: column;
        min-height: 0;
        overflow: hidden;
      }
      .candidates-panel {
        background: #f8fafc;
        overflow: hidden;
      }
      .authors-list {
        flex: 1;
        min-height: 0;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 0.6rem;
      }
      .author-row {
        border-radius: 12px;
        border: 1px solid transparent;
        padding: 0.85rem;
        background: #f8fafc;
        text-align: left;
        cursor: pointer;
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
        transition:
          background 0.2s ease,
          border-color 0.2s ease;
        font-family: inherit;
      }
      .author-row:hover,
      .author-row:focus-visible {
        border-color: #c7d2fe;
        background: #ffffff;
        outline: none;
      }
      .author-row.selected {
        border-color: #2563eb;
        background: #eef2ff;
      }
      .author-row.queued {
        border-color: #65a30d;
        background: #f0fdf4;
      }
      .author-row .author-name {
        font-weight: 600;
        font-size: 1rem;
        margin: 0;
      }
      .author-row .author-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        align-items: center;
        font-size: 0.85rem;
        color: #475569;
      }
      .author-meta a {
        color: #2563eb;
        text-decoration: none;
        font-weight: 600;
      }
      .author-meta .scholia-link {
        color: #15803d;
        font-size: 0.8rem;
        font-weight: 500;
      }
      .author-meta .disambig-link {
        color: #b45309;
        font-size: 0.8rem;
        font-weight: 500;
      }

      .author-count {
        font-weight: 500;
        color: #1e293b;
      }
      .doi-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 0.35rem;
        font-size: 0.8rem;
        color: #475569;
      }
      .doi-meta code {
        background: #eef2ff;
        padding: 0 0.35rem;
        border-radius: 3px;
        border: 1px solid #c7d2fe;
      }
      .candidate-header {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }
      .candidate-title {
        margin: 0;
        font-size: 1.4rem;
      }
      .candidate-subtitle {
        margin: 0;
        font-size: 0.95rem;
        color: #475569;
      }
      .candidate-list {
        display: flex;
        flex-direction: column;
        gap: 0.9rem;
        flex: 1;
        min-height: 0;
        overflow-y: auto;
      }
      .candidate-card {
        padding: 1rem;
        border-radius: 14px;
        background: #ffffff;
        border: 1px solid #e0e7ff;
        display: flex;
        justify-content: space-between;
        gap: 1rem;
        flex-wrap: wrap;
        align-items: center;
      }
      .candidate-info {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
      }
      .candidate-name {
        font-weight: 600;
        margin: 0;
        font-size: 1rem;
      }
      .candidate-meta {
        margin: 0;
        font-size: 0.85rem;
        color: #475569;
      }
      .candidate-meta a {
        color: #2563eb;
        text-decoration: none;
      }
      .candidate-actions button {
        padding: 0.55rem 0.95rem;
        border-radius: 10px;
        border: none;
        background: #2563eb;
        color: #fff;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s ease;
      }
      .candidate-actions button:active {
        transform: scale(0.97);
      }
      .queue {
        border-radius: 14px;
        background: #ffffff;
        border: 1px solid #c7d2fe;
        padding: 1rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        flex-shrink: 0;
      }
      .queue h3 {
        margin: 0;
        font-size: 1rem;
      }
      .queue-list {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        min-height: 0;
        max-height: 220px;
        overflow-y: auto;
      }
      .queue-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: #ffffff;
        border: 1px solid #dbeafe;
        border-radius: 8px;
        padding: 0.4rem 0.75rem;
        font-size: 0.9rem;
      }
      .queue-item button {
        padding: 0.35rem 0.75rem;
        border-radius: 6px;
        border: 1px solid #2563eb;
        background: transparent;
        color: #2563eb;
        cursor: pointer;
        font-size: 0.85rem;
      }
      .queue-actions {
        display: flex;
        gap: 0.6rem;
        flex-wrap: wrap;
      }
      .queue-actions button {
        flex: 1;
        min-width: 140px;
        padding: 0.55rem 1rem;
        border-radius: 10px;
        border: none;
        cursor: pointer;
        font-weight: 600;
      }
      .open-qs {
        background: #0f172a;
        color: #fff;
      }
      .clear-queue {
        background: transparent;
        border: 1px solid #475569;
        color: #475569;
      }
      .empty-state {
        padding: 1rem;
        border-radius: 12px;
        background: rgba(37, 99, 235, 0.07);
        border: 1px dashed rgba(37, 99, 235, 0.35);
        color: #1e293b;
        font-size: 0.95rem;
      }
      .small-link {
        margin: 0.35rem 0 0;
        color: #475569;
        font-size: 0.8rem;
      }
      @media (max-width: 1024px) {
        .master-detail {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="app">
      <header class="hero">
        <div>
          <h1>ORCID Matcher</h1>
          <p>
            Run a SPARQL query (via Qlever) to find authors with DOIs published
            after 2011 who still lack an ORCID (P496). Enter ORCIDs for authors
            you are confident about and queue them for a batch QuickStatements
            export.
          </p>
          <p>
            Important: ORCID Matcher does not verify whether an ORCID is already
            registered, and some researchers may appear twice in Wikidata—once
            with an ORCID and once without. After adding each ORCID, check the
            author’s Wikidata item so you don’t introduce a duplicate; the
            interface flags duplicates automatically.
          </p>
          <p class="small-link">
            Powered by Wikidata SPARQL + Crossref — generated in your browser. ·
            <a
              href="https://github.com/davidoskky/orcid-matcher"
              target="_blank"
              rel="noopener"
              >GitHub repo</a
            >
          </p>
        </div>
        <div class="controls">
          <textarea id="query" spellcheck="false"></textarea>
          <div class="controls-row">
            <button id="run-query">Run query</button>
          </div>
          <p class="status" id="status">Ready.</p>
        </div>
      </header>
      <div class="master-detail">
        <aside class="panel authors-panel">
          <div class="panel-header">
            <div>
              <h2>Authors</h2>
              <p>Filter by name, QID, or DOI on this panel.</p>
            </div>
          </div>
          <input
            id="author-filter"
            class="inline-field"
            type="search"
            placeholder="Filter researchers (name, ORCID, DOI)"
            aria-label="Filter authors"
          />
          <div id="author-list" class="authors-list" role="list"></div>
        </aside>
        <section class="panel candidates-panel">
          <div class="panel-header">
            <div class="candidate-header">
              <h2 id="candidate-title" class="candidate-title">
                Select an author
              </h2>
              <p id="candidate-subtitle" class="candidate-subtitle">
                No author chosen yet.
              </p>
            </div>
            <input
              id="candidate-filter"
              class="inline-field"
              type="search"
              placeholder="Filter candidates by name"
              aria-label="Filter ORCID candidates by name"
              disabled
            />
          </div>
          <div id="candidate-list" class="candidate-list"></div>
          <div class="queue" id="queue">
            <h3>Queue</h3>
            <div class="queue-list" id="queue-list"></div>
            <div class="queue-actions">
              <button class="open-qs" id="open-qs" disabled>
                Open QuickStatements
              </button>
              <button class="clear-queue" id="clear-queue" disabled>
                Clear queue
              </button>
            </div>
          </div>
        </section>
      </div>
    </div>
    <script>
      const statusEl = document.getElementById("status");
      const openBtn = document.getElementById("open-qs");
      const clearBtn = document.getElementById("clear-queue");
      const queueList = document.getElementById("queue-list");
      const runBtn = document.getElementById("run-query");
      const textarea = document.getElementById("query");
      const authorFilterInput = document.getElementById("author-filter");
      const authorListEl = document.getElementById("author-list");
      const candidateFilterInput = document.getElementById("candidate-filter");
      const candidateListEl = document.getElementById("candidate-list");
      const candidateTitleEl = document.getElementById("candidate-title");
      const candidateSubtitleEl = document.getElementById("candidate-subtitle");

      const QUEUE = [];
      const candidateCache = new Map();
      const authorRowMap = new Map();
      const candidateCounts = new Map();
      const candidateLoadPromises = new Map();
      const queuedAuthors = new Set();
      let latestResults = [];
      let selectedAuthor = null;
      let currentCandidates = [];
      let filterValue = "";

      const DEFAULT_QUERY = `PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX wd: <http://www.wikidata.org/entity/>
PREFIX wdt: <http://www.wikidata.org/prop/direct/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>

SELECT DISTINCT ?person ?personLabel ?doi WHERE {
  ?work wdt:P356 ?doi ;
        wdt:P50  ?person ;
        wdt:P577 ?date .

  FILTER(?date > "2011-12-31T23:59:59Z"^^xsd:dateTime)
  ?person wdt:P31 wd:Q5 .
  FILTER NOT EXISTS { ?person wdt:P496 [] }

  OPTIONAL { ?person rdfs:label ?personLabel . FILTER(LANG(?personLabel) = "en") }
}
ORDER BY RAND()
LIMIT 200`;
      textarea.textContent = DEFAULT_QUERY;

      runBtn.addEventListener("click", async () => {
        if (!textarea.value.trim()) return;
        runBtn.disabled = true;
        statusEl.textContent = "Querying via Qlever...";
        authorListEl.innerHTML = "";
        try {
          const data = await fetchQuery(textarea.value);
          renderResults(data);
        } catch (error) {
          authorListEl.innerHTML =
            '<div class="empty-state">Unable to fetch authors.</div>';
          statusEl.textContent = `Error: ${error.message}`;
        } finally {
          runBtn.disabled = false;
        }
      });

      authorFilterInput.addEventListener("input", () => {
        filterValue = authorFilterInput.value.trim().toLowerCase();
        renderResults(latestResults);
      });

      candidateFilterInput.addEventListener("input", () => {
        renderCandidateList();
      });

      async function fetchQuery(sparql) {
        const url = "https://qlever.dev/api/wikidata";
        const resp = await fetch(url, {
          method: "POST",
          headers: {
            Accept: "application/sparql-results+json",
            "Content-Type": "application/sparql-query",
          },
          body: sparql,
        });
        if (!resp.ok) throw new Error(`SPARQL error (${resp.status})`);
        const json = await resp.json();
        const bindings = json?.results?.bindings || [];
        const people = new Map();
        for (const binding of bindings) {
          const qid = binding.person.value.split("/").pop();
          const label = binding.personLabel?.value || qid;
          const doi = binding.doi?.value;
          if (!people.has(qid)) {
            people.set(qid, { qid, label, dois: new Set() });
          }
          if (doi) {
            people.get(qid).dois.add(doi);
          }
        }
        return Array.from(people.values()).map((entry) => ({
          qid: entry.qid,
          label: entry.label,
          dois: Array.from(entry.dois),
        }));
      }

      function renderResults(results) {
        latestResults = Array.isArray(results) ? results : [];
        filterValue = authorFilterInput.value.trim().toLowerCase();
        const filtered = applyRowFilter(latestResults);
        if (
          selectedAuthor &&
          !latestResults.some((item) => item.qid === selectedAuthor.qid)
        ) {
          selectedAuthor = null;
          currentCandidates = [];
        }
        authorRowMap.clear();
        authorListEl.innerHTML = "";
        if (!latestResults.length) {
          authorListEl.innerHTML =
            '<div class="empty-state">Run the query to populate this list.</div>';
          statusEl.textContent = "No researchers found.";
          renderCandidateList();
          return;
        }
        if (!filtered.length) {
          authorListEl.innerHTML =
            '<div class="empty-state">No researchers match that filter.</div>';
        } else {
          filtered.forEach((item) => {
            const row = document.createElement("div");
            row.className = "author-row";
            row.setAttribute("role", "button");
            row.setAttribute("tabindex", "0");
            row.dataset.qid = item.qid;
            if (selectedAuthor && selectedAuthor.qid === item.qid) {
              row.classList.add("selected");
            }
            const doiHtml = item.dois.length
              ? `<div class="doi-meta">${item.dois
                  .map((doi) => `<code>${doi}</code>`)
                  .join(" ")}</div>`
              : `<div class="doi-meta"><em>No DOI captured</em></div>`;
            const countText = getAuthorCandidateCountText(item.qid);
            row.innerHTML = `
              <span class="author-name">${item.label}</span>
              <div class="author-meta">
                <a class="author-qid" href="https://www.wikidata.org/wiki/${item.qid}" target="_blank" rel="noopener">${item.qid}</a>
                <a class="scholia-link" href="https://scholia.toolforge.org/author/${item.qid}" target="_blank" rel="noopener">Scholia</a>
                <a class="disambig-link" href="https://author-disambiguator.toolforge.org/author_item_oauth.php?id=${item.qid}&doit=Get+author+data&filter=" target="_blank" rel="noopener">Disambig</a>
                <span class="author-count">${countText}</span>
              </div>
              ${doiHtml}
            `;

            row.addEventListener("click", () => handleAuthorSelect(item));
            row.addEventListener("keydown", (event) => {
              if (event.key === "Enter" || event.key === " ") {
                event.preventDefault();
                handleAuthorSelect(item);
              }
            });
            const qLink = row.querySelector(".author-qid");
            if (qLink) {
              qLink.addEventListener("click", (event) =>
                event.stopPropagation(),
              );
            }
            authorRowMap.set(item.qid, row);
            applyAuthorQueuedClass(item.qid);
            updateAuthorVisibility(item.qid);
            authorListEl.appendChild(row);
          });
        }

        if (filterValue) {
          statusEl.textContent = `Showing ${filtered.length}/${latestResults.length} researchers matching filter.`;
        } else {
          statusEl.textContent = `Found ${latestResults.length} potential researchers.`;
        }
        renderCandidateList();
        autoLoadCandidatesFor(filtered);
      }

      function renderCandidateList() {
        if (!selectedAuthor) {
          candidateTitleEl.textContent = "Select an author";
          candidateSubtitleEl.textContent = "No author chosen yet.";
          candidateFilterInput.disabled = true;
          candidateListEl.innerHTML =
            '<div class="empty-state">Click an author to load ORCID candidates.</div>';
          return;
        }
        candidateTitleEl.textContent = selectedAuthor.label;
        candidateSubtitleEl.textContent = `${selectedAuthor.qid} · sorted by name similarity`;
        candidateFilterInput.disabled = false;
        const targetName = selectedAuthor?.label || "";
        const filterTerm = candidateFilterInput.value.trim().toLowerCase();
        const matches = currentCandidates
          .map((candidate) => ({
            candidate,
            similarity: calculateNameSimilarity(
              candidate.name || candidate.orcid,
              targetName,
            ),
          }))
          .filter(({ candidate }) => {
            const name = (
              candidate.name ||
              candidate.orcid ||
              ""
            ).toLowerCase();
            return name.includes(filterTerm);
          })
          .sort((a, b) => b.similarity - a.similarity);
        if (!matches.length) {
          candidateListEl.innerHTML = currentCandidates.length
            ? '<div class="empty-state">No candidates match that name filter.</div>'
            : '<div class="empty-state">No ORCID candidates loaded yet for this author.</div>';
          return;
        }
        candidateListEl.innerHTML = "";
        matches.forEach(({ candidate }) => {
          const card = document.createElement("article");
          card.className = "candidate-card";
          card.innerHTML = `
            <div class="candidate-info">
              <p class="candidate-name">${candidate.name || candidate.orcid}</p>
              <p class="candidate-meta">
                <a href="https://orcid.org/${candidate.orcid}" target="_blank" rel="noopener">${candidate.orcid}</a>
              </p>
            </div>
            <div class="candidate-actions">
              <button type="button">Add ORCID</button>
            </div>
          `;

          card.querySelector("button").addEventListener("click", () => {
            upsertQueue({
              qid: selectedAuthor.qid,
              label: selectedAuthor.label,
              orcid: candidate.orcid,
            });
            statusEl.textContent = `Queued ${selectedAuthor.label} → ${candidate.orcid}`;
          });
          candidateListEl.appendChild(card);
        });
      }

      function handleAuthorSelect(author) {
        selectedAuthor = author;
        candidateFilterInput.value = "";
        currentCandidates = candidateCache.get(author.qid) || [];
        renderResults(latestResults);
        loadCandidates(author).catch((error) => {
          console.warn("Candidate load failed", error);
        });
      }

      async function loadCandidates(item) {
        const key = item.qid;
        if (candidateCache.has(key)) {
          currentCandidates = candidateCache.get(key);
          renderCandidateList();
          setAuthorCandidateState(key, currentCandidates.length, false, true);
          statusEl.textContent = `${currentCandidates.length} cached candidate(s) for ${item.label}.`;
          return;
        }
        if (candidateLoadPromises.has(key)) {
          return candidateLoadPromises.get(key);
        }
        markAuthorLoading(key);
        statusEl.textContent = `Gathering ORCID candidates for ${item.label}...`;
        const loadPromise = (async () => {
          const missingDois = [];
          if (!item.dois?.length) {
            try {
              item.dois = await fetchPersonDois(item.qid);
            } catch (error) {
              console.warn("DOI lookup failed", error);
            }
          }
          const map = new Map();
          for (const doi of item.dois || []) {
            if (!doi) continue;
            try {
              const data = await fetchCrossref(doi);
              const authors = Array.isArray(data?.message?.author)
                ? data.message.author
                : [];
              for (const author of authors) {
                const orcid = normalizeOrcid(author?.ORCID || author?.orcid);
                if (!orcid) continue;
                const entry = map.get(orcid) || {
                  orcid,
                  name: formatAuthorName(author),
                  dois: new Set(),
                };
                entry.name = entry.name || formatAuthorName(author);
                entry.dois.add(doi);
                map.set(orcid, entry);
              }
            } catch (error) {
              console.warn("Crossref lookup failed", doi, error);
              missingDois.push(doi);
            }
          }
          const candidates = Array.from(map.values()).map((entry) => ({
            orcid: entry.orcid,
            name: entry.name,
            dois: Array.from(entry.dois),
          }));
          candidateCache.set(key, candidates);
          setAuthorCandidateState(key, candidates.length, false, true);
          currentCandidates = candidates;
          renderCandidateList();
          let status = candidates.length
            ? `${candidates.length} ORCID candidate(s) available.`
            : "No ORCID candidates found.";
          if (missingDois.length) {
            status += ` Missing DOIs: ${missingDois.join(", ")}`;
          }
          statusEl.textContent = status;
        })()
          .catch((error) => {
            setAuthorCandidateState(
              key,
              candidateCounts.get(key)?.count ?? 0,
              false,
              false,
            );
            statusEl.textContent = `Error: ${error.message}`;
            throw error;
          })
          .finally(() => {
            candidateLoadPromises.delete(key);
          });
        candidateLoadPromises.set(key, loadPromise);
        return loadPromise;
      }

      const CROSSREF_BASE = "https://api.crossref.org/works/";
      const CROSSREF_HEADERS = { Accept: "application/json" };
      const SCHOLARLY_ENDPOINT = "https://query-scholarly.wikidata.org/sparql";

      function fetchCrossref(doi) {
        const url = CROSSREF_BASE + encodeURIComponent(doi);
        return fetch(url, { headers: CROSSREF_HEADERS }).then((resp) => {
          if (!resp.ok) throw new Error(`Crossref error (${resp.status})`);
          return resp.json();
        });
      }

      async function fetchPersonDois(qid) {
        const sparql = `SELECT DISTINCT ?work ?doi WHERE {
  ?work wdt:P50 wd:${qid} ;
        wdt:P356 ?doi .
}
ORDER BY ?work
LIMIT 200`;
        const resp = await fetch(SCHOLARLY_ENDPOINT, {
          method: "POST",
          headers: {
            Accept: "application/sparql-results+json",
            "Content-Type": "application/x-www-form-urlencoded",
          },
          body: "query=" + encodeURIComponent(sparql),
        });
        if (!resp.ok)
          throw new Error(`Scholarly query failed (${resp.status})`);
        const data = await resp.json();
        const dois = new Set();
        (data?.results?.bindings || []).forEach((binding) => {
          const value = binding?.doi?.value;
          if (value) {
            dois.add(value.toUpperCase());
          }
        });
        return Array.from(dois);
      }

      function formatAuthorName(author) {
        if (!author) return null;
        const given = nameValue(author.given || author["given-names"]);
        const family = nameValue(author.family || author["family-names"]);
        if (given && family) return `${given} ${family}`;
        return nameValue(author.name) || nameValue(author["credit-name"]);
      }

      function nameValue(value) {
        if (value == null) return null;
        if (typeof value === "string") {
          const trimmed = value.trim();
          return trimmed || null;
        }
        if (Array.isArray(value)) {
          for (const item of value) {
            const resolved = nameValue(item);
            if (resolved) return resolved;
          }
          return null;
        }
        if (typeof value === "object") {
          if ("value" in value) {
            return nameValue(value.value);
          }
          if ("name" in value) {
            return nameValue(value.name);
          }
        }
        return null;
      }

      function normalizeOrcid(value) {
        if (!value) return null;
        const cleaned = value.toUpperCase().trim();
        const match = cleaned.match(/\b\d{4}-\d{4}-\d{4}-\d{3}[\dX]\b/);
        return match ? match[0] : null;
      }

      function applyRowFilter(items) {
        if (!items.length) return [];
        if (!filterValue) return items;
        return items.filter((item) => {
          const haystack = [item.label, item.qid, ...(item.dois || [])]
            .filter(Boolean)
            .map((value) => value.toString().toLowerCase())
            .join(" ");
          return haystack.includes(filterValue);
        });
      }

      function normalizeNameForComparison(value) {
        return (value || "")
          .toString()
          .toLowerCase()
          .replace(/\s+/g, " ")
          .trim();
      }

      function levenshteinDistance(a, b) {
        const rows = a.length + 1;
        const cols = b.length + 1;
        const dp = Array.from({ length: rows }, () => Array(cols).fill(0));
        for (let i = 0; i < rows; i += 1) {
          dp[i][0] = i;
        }
        for (let j = 0; j < cols; j += 1) {
          dp[0][j] = j;
        }
        for (let i = 1; i < rows; i += 1) {
          for (let j = 1; j < cols; j += 1) {
            const cost = a[i - 1] === b[j - 1] ? 0 : 1;
            dp[i][j] = Math.min(
              dp[i - 1][j] + 1,
              dp[i][j - 1] + 1,
              dp[i - 1][j - 1] + cost,
            );
          }
        }
        return dp[a.length][b.length];
      }

      function calculateNameSimilarity(name, target) {
        const normalizedName = normalizeNameForComparison(name);
        const normalizedTarget = normalizeNameForComparison(target);
        if (!normalizedName || !normalizedTarget) return 0;
        const distance = levenshteinDistance(normalizedName, normalizedTarget);
        const maxLength = Math.max(
          normalizedName.length,
          normalizedTarget.length,
        );
        return maxLength ? 1 - distance / maxLength : 0;
      }

      function getAuthorCandidateCountText(qid) {
        const entry = candidateCounts.get(qid);
        if (!entry) return "0 candidates";
        if (entry.loading) return "Loading…";
        if (entry.loaded) {
          const count = entry.count ?? 0;
          return `${count} candidate${count === 1 ? "" : "s"}`;
        }
        return "0 candidates";
      }

      function refreshAuthorCount(qid) {
        const row = authorRowMap.get(qid);
        if (!row) return;
        const badge = row.querySelector(".author-count");
        if (badge) {
          badge.textContent = getAuthorCandidateCountText(qid);
        }
      }

      function setAuthorCandidateState(
        qid,
        count,
        loading = false,
        loaded = false,
      ) {
        candidateCounts.set(qid, { count, loading, loaded });
        refreshAuthorCount(qid);
        updateAuthorVisibility(qid);
      }

      function markAuthorLoading(qid) {
        const current = candidateCounts.get(qid) || { count: 0 };
        setAuthorCandidateState(qid, current.count ?? 0, true, false);
      }

      function autoLoadCandidatesFor(items) {
        items.forEach((item) => {
          loadCandidates(item).catch((error) => {
            console.warn("Auto load error", item.qid, error);
          });
        });
      }

      function updateAuthorVisibility(qid) {
        const row = authorRowMap.get(qid);
        if (!row) return;
        const entry = candidateCounts.get(qid);
        const shouldHide =
          entry && !entry.loading && entry.loaded && entry.count === 0;
        row.hidden = shouldHide;
        row.style.display = shouldHide ? "none" : "flex";
      }

      function applyAuthorQueuedClass(qid) {
        const row = authorRowMap.get(qid);
        if (!row) return;
        row.classList.toggle("queued", queuedAuthors.has(qid));
      }

      function setAuthorQueuedState(qid, queued) {
        if (queued) {
          queuedAuthors.add(qid);
        } else {
          queuedAuthors.delete(qid);
        }
        applyAuthorQueuedClass(qid);
      }

      function upsertQueue(entry) {
        const exists = QUEUE.find((item) => item.qid === entry.qid);
        if (exists) {
          exists.orcid = entry.orcid;
          exists.label = entry.label;
        } else {
          QUEUE.push(entry);
        }
        setAuthorQueuedState(entry.qid, true);
        renderQueue();
      }

      function renderQueue() {
        queueList.innerHTML = "";
        if (!QUEUE.length) {
          queueList.innerHTML =
            "<p>Add a researcher above to build your queue.</p>";
          openBtn.disabled = true;
          clearBtn.disabled = true;
          return;
        }
        QUEUE.forEach((item, idx) => {
          const div = document.createElement("div");
          div.className = "queue-item";
          div.innerHTML = `
            <span>${item.label} (${item.qid}) → ${item.orcid}</span>
            <button type="button" data-index="${idx}">Remove</button>
          `;
          div.querySelector("button").addEventListener("click", () => {
            const removed = QUEUE.splice(idx, 1);
            removed.forEach((item) => setAuthorQueuedState(item.qid, false));
            renderQueue();
          });
          queueList.appendChild(div);
        });
        openBtn.disabled = false;
        clearBtn.disabled = false;
      }

      clearBtn.addEventListener("click", () => {
        const queued = Array.from(queuedAuthors);
        QUEUE.length = 0;
        queued.forEach((qid) => setAuthorQueuedState(qid, false));
        renderQueue();
      });

      openBtn.addEventListener("click", () => {
        if (!QUEUE.length) return;
        const lines = QUEUE.map((item) =>
          [item.qid, "P496", `"${item.orcid}"`].join("\t"),
        );
        openQuickStatements(lines);
      });

      function openQuickStatements(lines) {
        const raw = lines.join("\n");
        const v1urlText = raw
          .trim()
          .replace(/\r\n?/g, "\n")
          .replace(/\t/g, "|")
          .replace(/\n/g, "||");
        const url =
          "https://qs-dev.toolforge.org/batch/new?v1=" +
          encodeURIComponent(v1urlText);
        window.open(url, "_blank", "noopener");
      }

      renderResults(latestResults);
      renderCandidateList();
      renderQueue();
    </script>
  </body>
</html>
